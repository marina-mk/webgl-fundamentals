export default "<% if (vert) { %>\n    #define PI 3.141592653589793\n  \n    precision highp float; \n\n    attribute vec2 aUvs;\n    attribute vec3 aPos;\n    attribute vec3 aNextPos;\n    attribute vec3 aNormal;\n    attribute vec3 aNextNormal;\n    attribute vec3 aFinalPos;\n    attribute vec3 aFinalNormal;\n\n    uniform mat4 uPMatrix;\n    uniform mat4 uMMatrix;\n    uniform mat4 uVMatrix;\n    uniform mat4 uNMatrix;\n\n    uniform vec3 uEye;\n    uniform vec3 uBendX;\n\n    uniform float uTime;\n    uniform float uRippleTime;\n    uniform float uBlendStrength;\n    uniform float uRippleSize;\n    uniform float uFinalProgress;\n    uniform float uPass;    \n\n    uniform sampler2D uNoise;\n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPos;\n    varying vec3 vPeye;\n\n    const float maxPos = 50.;\n\n    float sineInOut(float t) {\n        return -0.5 * (cos(PI * t) - 1.0);\n    }\n\n    mat4 rotationX( float angle ) {\n        return mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n                        0, \tcos(angle),\t-sin(angle),\t\t0,\n                        0, \tsin(angle),\t cos(angle),\t\t0,\n                        0, \t\t\t0,\t\t\t  0, \t\t1);\n    }\n\n    mat4 rotationZ( float angle ) {\n        return mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n                        sin(angle),\t\tcos(angle),\t\t0,\t0,\n                                0,\t\t\t\t0,\t\t1,\t0,\n                                0,\t\t\t\t0,\t\t0,\t1);\n    }\n\n    void main(){\n        vUv = aUvs;\n\n        aFinalNormal;\n        aFinalPos;\n\n        vec3 nextDiffPos = aNextPos - aPos;\n        vec3 nextDiffNorm = aNextNormal - aNormal;\n\n        vec3 pos = aPos;\n        pos += nextDiffPos * uBlendStrength;\n        vec3 norm = aNormal;\n        norm += nextDiffNorm * uBlendStrength;\n\n        vec4 mp = uMMatrix * vec4(pos, 1);\n        vPeye = normalize(mp.xyz - uEye);\n\n        // pos.x -= uBendZ.x;\n        // vec4 posRotZ = vec4(pos, 1.);\n        // posRotZ *= rotationZ(min(max(pos.x/(uBendZ.y - uBendZ.x), -1.), 1.) * uBendZ.z * .5);\n        // vec4 normRotZ = vec4(norm, 1.);\n        // normRotZ *= rotationZ(min(max(pos.x/(uBendZ.y - uBendZ.x), -1.), 1.) * uBendZ.z * .5);\n        // pos = posRotZ.xyz;\n        // norm = normRotZ.xyz;\n        // pos.x += uBendZ.x;\n        vec2 dispUv = aUvs;\n        dispUv *= 0.05;\n        dispUv.x += (uRippleTime * .005);\n        dispUv.y += (uRippleTime * .003);\n\n        vPos = pos;\n        pos.y += (texture2D( uNoise, dispUv ).x * 2.0 - 1.0) * uRippleSize * .1;\n        pos.y += sin(uTime + aUvs.x * 5.) * .1;\n        pos.y += sin(uTime + aUvs.y * 8.) * .15;\n\n        // pos.z -= uBendX.x;\n        // vec4 posRotX = vec4(pos, 1.);\n        // posRotX *= rotationX(min(max(pos.z/(uBendX.y - uBendX.x), -1.), 1.) * uBendX.z * .5);\n        // vec4 normRotX = vec4(norm, 1.);\n        // normRotX *= rotationX(min(max(pos.z/(uBendX.y - uBendX.x), -1.), 1.) * uBendX.z * .5);\n        // pos = posRotX.xyz;\n        // norm = normRotX.xyz;\n        // // pos.y *= 0.585786438;\n        // pos.z += uBendX.x;\n\n\n        pos = mix(pos, aFinalPos, uFinalProgress);\n        norm = mix(norm, aFinalNormal, uFinalProgress);\n\n        vNormal = normalize((uNMatrix * vec4(norm, 0.0)).xyz);\n        vNormal = mat3(uVMatrix) * vNormal;\n        vPeye = mat3(uVMatrix) * vPeye;\n\n        mat4 viewMatrix = uVMatrix;\n        float reflectionScale = -((uPass * 2.) - 1.);\n        viewMatrix[1][0] *= reflectionScale;\n        viewMatrix[1][1] *= reflectionScale;\n        viewMatrix[1][2] *= reflectionScale;\n        viewMatrix[1][3] *= reflectionScale;\n\n        gl_Position = uPMatrix * viewMatrix * uMMatrix * vec4(pos, 1.0);\n\n    }\n\n<% } %>\n\n\n\n<% if (frag) { %>\n    #extension GL_EXT_shader_texture_lod : enable\n    #extension GL_OES_standard_derivatives : enable\n\n    precision highp float; \n\n    varying vec2 vUv;\n    varying vec3 vNormal;\n    varying vec3 vPos;\n    varying vec3 vPeye;\n\n    uniform sampler2D uMatcap;\n    uniform sampler2D uNormalMap;\n\n    uniform float uNormalStrength;\n    uniform float uTime;\n    uniform float uOpacity;    \n\n    vec2 matcap(vec3 eye, vec3 normal) {\n        vec3 reflected = reflect(eye, normal);\n        float m = 2.8284271247461903 * sqrt( reflected.z+1.0 );\n        return reflected.xy / m + 0.5;\n    }\n\n    void main() {   \n\n        // compute derivations of the world position\n        vec3 p_dx = dFdx(vPos);\n        vec3 p_dy = dFdy(vPos);\n        // compute derivations of the texture coordinate\n        vec2 tc_dx = dFdx(vUv);\n        vec2 tc_dy = dFdy(vUv);\n        // compute initial tangent and bi-tangent\n        vec3 t = normalize( tc_dy.y * p_dx - tc_dx.y * p_dy );\n        vec3 b = normalize( tc_dy.x * p_dx - tc_dx.x * p_dy ); // sign inversion\n        // get new tangent from a given mesh normal\n        vec3 n = normalize(vNormal);\n        vec3 x = cross(n, t);\n        t = cross(x, n);\n        t = normalize(t);\n        // get updated bi-tangent\n        x = cross(b, n);\n        b = cross(n, x);\n        b = normalize(b);\n        mat3 tbn = mat3(t, b, n);\n\n\t\tvec3 finalNormal = vNormal;\n        vec3 normalTex = texture2D( uNormalMap, vUv * 1. ).xyz * 2.0 - 1.0;\n        normalTex.xy *= uNormalStrength;\n        normalTex.y *= -1.;\n        normalTex = normalize( normalTex );\n        finalNormal = tbn * normalTex;\n\n        vec2 uv = matcap(vPeye, finalNormal);\n\n        vec3 color = texture2D( uMatcap, uv ).xyz;\n        gl_FragColor = vec4(color, uOpacity); \n    } \n        \n<% } %>\n\n\n\n";